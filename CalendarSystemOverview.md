# Admin Availability Calendar – System Overview

## 1. What lives at `/admin/calendar`

- The page component (`src/app/admin/calendar/page.tsx`) is a simple client component that renders `<AvailabilityCalendar />`.
- `AvailabilityCalendar` (`src/components/shared/availability-calendar.tsx`) drives the entire “Availability Overview Calendar” experience, wiring data, controls, table layout, hover tooling, and fallback flows.
- Supporting pieces:
  - `RoomTypeRow` (`src/components/shared/room-type-row.tsx`) renders each aggregated room type and, on demand, individual room rows.
  - `ReservationHoverCard` (`src/components/shared/reservation-hover-card.tsx`) shows booking details, payment status, and guest context.
  - `useMonthlyAvailability` (`src/hooks/use-monthly-availability.ts`) fetches aggregated availability for a selected month.
  - `getMonthlyAvailability` API helper (`src/lib/api/index.ts`) calls the Supabase RPC `get_monthly_availability` (defined in migrations such as `0036`–`0039`).
  - `useDataContext` (`src/context/data-context.tsx`) supplies property configuration, reservations, guests, rooms, and room types pulled from `useAppData`.

## 2. Data sources & shared helpers

- `useDataContext()` exposes:
  - `property`: controls `defaultUnitsView`, `showPartialDays`, `currency`, and `allowSameDayTurnover`.
  - `reservations`, `guests`, `rooms`, `roomTypes`: used for hover cards, legacy mode, and per-room expansion.
- `buildReservationMeta` in `AvailabilityCalendar` pre-computes guest + room info per reservation to support metadata lookups.
- `RoomTypeRow` maintains a memoized reservation map keyed by room to answer “who is in this room on this day?” for the legacy-style expansion.
- Styling helpers from `date-fns`, `lucide-react`, and local utilities (`cn`, Shadcn UI components) provide consistent UI building blocks.

## 3. Modern “Availability Overview” UI

### 3.1 Header controls

- Month navigation: arrow buttons (`ChevronLeft`, `ChevronRight`) bump `currentMonth` state via `subMonths`/`addMonths`.
- Month picker: `<Select>` contains 12 future-looking options generated by `buildMonthOptions`, anchored to today unless the currently viewed month is earlier.
- Units toggle: second `<Select>` switches between `remaining` (“Units left”) and `booked` views, defaulting to `property.defaultUnitsView` and synced when the property changes.
- State resets: changing months clears any selected cell, and selecting a month re-parses ISO strings via `parseISO`.

### 3.2 Loading and RPC error handling

- `useMonthlyAvailability(currentMonth)` exposes `{data, isLoading, error}`.
- While loading, a `Skeleton` placeholder replaces the table.
- If Supabase errors, `rpcError` displays a dismissible alert with an option to “Use legacy view.” Choosing legacy flips `useLegacyView` and swaps in the older calendar implementation.

### 3.3 Table structure & interaction (`RoomTypeRow`)

- The table header shows one sticky column with the month label and one column per day (from `buildHeaderDays`, which falls back to the full month when RPC data is absent).
- Each `RoomTypeRow` renders:
  - A summary row with expandable caret, room-type name, and unit count badge.
  - One cell per day, built from RPC data. Class variants reflect `AvailabilityCellStatus` (`free`, `partial`, `busy`, `closed`), adjusted by `property.showPartialDays`.
  - Unit numbers: either `unitsTotal - bookedCount` (remaining) or `bookedCount` (booked view). Zero-availability days hide numbers unless showing booked counts.
  - Check-in / check-out flags using `hasCheckIn` and `hasCheckOut` booleans.
  - Closed icons: when `day.isClosed` is true a lock icon warns that inventory is blocked.
  - Click handling: `handleCellSelection` ignores `busy`/`closed` cells and toggles selection state per room type + date. Today’s cell gets a faint ring; selected cells show `ring-2` styling.
  - Tooltips: days with `reservationIds` wrap the button in `ReservationHoverCard`; otherwise a basic tooltip shows “X of Y units booked.”
- Expanding a room type unveils per-room rows:
  - Each room row iterates the same days, calls `getReservationForRoomOnDate` (hotel-style `[checkIn, checkOut)` intervals) to find an occupant, and displays either a blank/free cell or a booking ribbon colored by reservation status.
  - Hovering the ribbon again invokes `ReservationHoverCard` with the single reservation id.

### 3.4 Legend & partial-day messaging

- A legend beneath the table explains color coding for `free`, `partial`, `busy`, and `closed` states.
- If the property hides partial days, the legend filters out the “Partially booked” item to stay truthful to the view.

## 4. Booked-room metadata rendering

- `ReservationHoverCard` pulls live data from `useDataContext` to hydrate each reservation id:
  - Resolves guest name, room number, and room type name.
  - Shows booking id (last 7 characters), booked nights, headcounts, check-in/out dates, and payment summaries.
  - Computes payment breakdown using `calculateReservationFinancials` and `resolveReservationTaxConfig`, formatting amounts with `formatCurrencyValue` and property currency.
  - Displays a badge representing `ReservationStatus` (e.g., Tentative, Confirmed, Checked-in) with matching ribbon styles.
- Aggregated days can show multiple bookings in one hover card; expanded room rows always show at most one booking per cell.

## 5. Availability computation pipeline

### 5.1 Client hook (`useMonthlyAvailability`)

- Normalizes the month to `YYYY-MM-01` via `formatMonthStart`.
- Tracks a memoized `roomTypeKey` so dependency arrays stay stable even when the same ids are re-ordered.
- On effect run, calls `getMonthlyAvailability`, stores the result list of `RoomTypeAvailability`, and surfaces errors.

### 5.2 API helper (`getMonthlyAvailability`)

- Calls `supabase.rpc('get_monthly_availability', { p_month_start, p_room_type_ids })`.
- Maps raw rows with `mapMonthlyAvailabilityRow` (`src/lib/availability.ts`) to align with `RoomTypeAvailability` typings: `{ roomType: RoomAvailabilityMeta, availability: AvailabilityDay[] }`.

### 5.3 Supabase RPC (`supabase/migrations/0036-0039`)

- Primary steps executed inside the database:
  1. Determine a property (first by `id`) to obtain `allow_same_day_turnover` and scope closures.
  2. Build `rooms_by_type` (room type metadata + unit counts + room list). Migration `0039` changed the `JOIN` to `LEFT JOIN` so room types with zero rooms still appear.
  3. Generate every calendar day within the month.
  4. Pull `reservations_in_scope`: reservations overlapping the month for the targeted room types, excluding Cancelled.
  5. Gather closure windows from `property_closures` and seasonal booking restrictions (where `value.closed` is true).
  6. For each room type/day, compute:
     - `active_bookings` (rooms occupied that night).
     - `reservation_ids` array.
     - Check-in/check-out booleans and how many checkouts happen that day.
     - `is_closed` if any closure covers the date (property-level or restriction-level).
  7. Adjust `booked_effective`:
     - Full closure -> treat all units as booked.
     - If same-day turnover is disallowed, single-unit types carry over checkout pressure so the night stays “busy.”
  8. Emit JSON for each day containing `date`, `status`, `unitsTotal`, `bookedCount`, `reservationIds`, `hasCheckIn`, `hasCheckOut`, and `isClosed`.
- Status derivation:
  - `closed` when `unitsTotal == 0`, explicit closures, or property-level closures.
  - `free` when `booked_effective == 0`.
  - `busy` when `booked_effective >= units`.
  - Otherwise `partial`.
- Frontend `RoomTypeRow` simply visualizes these values; no extra math is done client-side beyond toggling between “units booked” and “units remaining.”

## 6. Legacy calendar mode

- Triggered when the user opts into the fallback after an RPC failure (`useLegacyView` flag).
- Renders a grid of physical rooms vs calendar days:
  - Days per month computed via `eachDayOfInterval(startOfMonth, endOfMonth)`.
  - Each room/day cell queries the reservations array directly (interval `[checkIn, checkOut)`) and collapses contiguous spans into a single `<TableCell colSpan={span}>` block.
  - Tooltips show guest names, reservation status, and date range.
  - Legend highlights primary statuses (Confirmed, Checked-in, Tentative).
- No aggregated availability metrics are shown here; it is purely room-level occupancy visualization for quick manual inspection.

## 7. End-to-end flow summary

1. User hits `/admin/calendar`; `AvailabilityCalendar` mounts as a client component.
2. `useDataContext` hydrates property/reservation/room data from `useAppData` (Supabase-backed fetches handled elsewhere).
3. The component sets its initial month (start of current month) and units view from the property default.
4. `useMonthlyAvailability` requests aggregated supply/demand for that month via the Supabase RPC.
5. Once data returns, each room type row is rendered with per-day buttons whose state (color, counts, check-in/out flags, closure lock) mirrors the RPC payload.
6. Hovering or expanding reveals reservation-level details sourced entirely from already-loaded context data, ensuring the calendar UI stays responsive without extra network calls.
7. Errors during aggregation invite the operator to switch to the legacy room-by-room calendar, guaranteeing that booking visibility is always available even if the RPC misbehaves.

## 8. Key takeaways

- Booked rooms are displayed by pairing aggregated RPC data (to show status/counts) with client-side reservation lookups (for hover cards and expanded rows).
- Availability calculations live in the database, considering reservations, closures, and property rules, then exposed via `useMonthlyAvailability`.
- The Availability Overview Calendar is entirely data-driven: UI state is confined to month navigation, units toggle, and selection, while actual capacity math is centralized in the Supabase function for consistency across the platform.
